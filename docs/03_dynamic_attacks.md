# Writing Dynamic Attack Scripts

Dynamic Attacks are Python scripts that apply **iterative, real-time transformations** to a payload during `spikee test`. They are the ideal tool for discovering novel bypasses when your initial, pre-defined prompts fail.

### Dynamic Attacks vs. Plugins: What's the Difference?

Both Dynamic Attacks and Plugins can generate variations of a payload, but they serve different purposes in the testing workflow:

*   **Dynamic Attacks (Real-Time Transformation):**
    *   **When they run:** During `spikee test`, but *only if* the initial, standard prompt fails.
    *   **What they do:** Generate and test variations one by one in real-time. The attack stops as soon as a variation succeeds.
    *   **Result:** Only the first successful variation (or the final failed attempt) is logged. This is useful for efficiently finding *any* successful bypass, potentially with adaptive logic that learns from previous failed attempts.

*   **Plugins (Pre-Test Transformation):**
    *   **When they run:** During `spikee generate`.
    *   **What they do:** Create multiple variations of a payload. Each variation is saved as a **separate, independent entry** in the final dataset file.
    *   **Result:** When you run `spikee test`, every single variation generated by the plugin is tested against the target. This is useful for systematically evaluating a target's resilience to a known set of transformations.

In short, use **Dynamic Attacks** to find a single successful bypass with adaptive, real-time logic. Use **Plugins** to build a comprehensive dataset of known transformations.

## Attack Structure

Every attack is a Python module located in the `attacks/` directory of your workspace. Spikee identifies attacks by their filename.

*   **Location:** `./attacks/my_adaptive_attack.py`
*   **Required Function:** `attack`

## The `attack` Function

This is the core of every dynamic attack script. It contains the logic for generating and testing payload variations until a success is found or the iteration limit is reached.

### Function Signature

```python
import threading
from typing import Tuple, Optional, Dict, Any

def attack(
    entry: Dict[str, Any],
    target_module: Any,
    call_judge: callable,
    max_iterations: int,
    attempts_bar: Optional[object] = None,
    bar_lock: Optional[threading.Lock] = None,
    attack_option: Optional[str] = None
) -> Tuple[int, bool, str, str]:
    """
    Executes an iterative attack strategy against a target.
    """
    # Your implementation here...
```

### Parameters

*   `entry: Dict[str, Any]`
    The dictionary for the original dataset entry that failed the initial test. You can access all its fields, such as `text`, `payload`, and `system_message`.

*   `target_module: Any`
    A **wrapped instance** of the target module. When you call `target_module.process_input()`, it automatically handles the retries and throttling defined in your `spikee test` command. You do not need to implement this logic yourself.

*   `call_judge: callable`
    A function that lets you evaluate if a response is successful. Call it with `call_judge(entry, response)` to get a `True` or `False` result.

*   `max_iterations: int`
    The maximum number of iterations your attack loop can run, as specified by `--attack-iterations`. Your loop **must** respect this limit.

*   `attempts_bar` and `bar_lock`
    `tqdm` progress bar objects for updating the UI. For each attempt inside your loop, call `with bar_lock: attempts_bar.update(1)`.

*   `attack_option: Optional[str]`
    A single string passed from the command line via `--attack-options` (e.g., `"mode=aggressive"`).

### Return Value

The `attack` function must return a tuple containing four elements:
1.  `int`: The total number of iterations that were attempted.
2.  `bool`: The final success flag (`True` if any iteration succeeded).
3.  `str`: The payload of the **last** attempted iteration.
4.  `str`: The response from the **last** attempted iteration.

## Implementation Guidelines

1.  **Modify the Payload**: It is best practice to modify the `entry['payload']` and substitute it back into `entry['text']`. This focuses the attack on the malicious part while preserving the surrounding document structure.
2.  **Respect `max_iterations`**: Your main loop must not exceed this value.
3.  **Update Progress Bar**: Call `attempts_bar.update(1)` inside the `bar_lock` for every iteration to keep the UI in sync.
4.  **Handle Early Exit**: If an attack succeeds, break the loop. Before returning, you should adjust the progress bar's total to reflect the skipped iterations. This keeps the ETA accurate.
5.  **Be Stateless**: An attack function should not carry state between different dataset entries. All necessary information should come from the `entry` dictionary.

## Complete Example: A Simple Mutation Attack

This example demonstrates an attack that repeatedly applies random character mutations to a payload until it succeeds.

```python
# ./attacks/random_mutate.py
import threading
import random
from typing import Tuple, Optional, Dict, Any

def _mutate(text: str) -> str:
    """Applies a single, random character substitution."""
    if not text:
        return ""
    idx = random.randint(0, len(text) - 1)
    char_to_replace = text[idx]
    # Simple mutation: replace with a similar-looking character or a special char
    mutations = {'a': '@', 's': '$', 'o': '0', 'l': '1', 'e': '3'}
    new_char = mutations.get(char_to_replace.lower(), '#')
    return text[:idx] + new_char + text[idx+1:]

def attack(
    entry: Dict[str, Any],
    target_module: Any,
    call_judge: callable,
    max_iterations: int,
    attempts_bar: Optional[object] = None,
    bar_lock: Optional[threading.Lock] = None,
    attack_option: Optional[str] = None
) -> Tuple[int, bool, str, str]:
    
    # 1. Get the part of the prompt to modify (the payload).
    original_text = entry.get("text", "")
    payload_to_modify = entry.get("payload", original_text)
    system_message = entry.get("system_message")
    
    last_payload = original_text
    last_response = ""
    current_payload_variant = payload_to_modify

    # 2. Loop up to the iteration limit.
    for i in range(1, max_iterations + 1):
        # 3. Generate the next attack variation.
        current_payload_variant = _mutate(current_payload_variant)
        
        # 4. Construct the full input text for the target.
        if entry.get("payload") and entry["payload"] in original_text:
            current_input = original_text.replace(entry["payload"], current_payload_variant)
        else:
            current_input = current_payload_variant
            
        last_payload = current_input

        # 5. Call the target and judge the response.
        try:
            response, _ = target_module.process_input(current_input, system_message)
            last_response = str(response)
            success = call_judge(entry, last_response)
        except Exception as e:
            last_response = f"Error during attack iteration {i}: {e}"
            success = False

        # 6. Update the shared progress bar.
        if attempts_bar and bar_lock:
            with bar_lock:
                attempts_bar.update(1)

        # 7. If successful, adjust the progress bar and return early.
        if success:
            if attempts_bar and bar_lock:
                with bar_lock:
                    remaining_iterations = max_iterations - i
                    if attempts_bar.total and attempts_bar.total > remaining_iterations:
                        attempts_bar.total -= remaining_iterations
            return i, True, last_payload, last_response

    # 8. If the loop finishes, return the final failed state.
    return max_iterations, False, last_payload, last_response
```